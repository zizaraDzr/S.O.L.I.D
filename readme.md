# SOLID

## S — Single responsibility principle — Принцип единой ответственности
> Функция, класс или модуль должны отвечать только за одну работу, иметь только одну причину для изменений.

[Пример на JS](public/1_S.js) - рендер вынесен в отдельный класс, а не все в одном большой классе.

#### Если говорить о фреймворках - то принцип единой ответственности можно перефразировать по-другому: 

>Каждый компонент должен иметь только одну причину изменения.

Вывод: каждый модуль, класс или компонент должен быть ответственен только за одну конкретную часть функциональности. Иными словами, у модуля должна быть только одна причина для изменения. Если у компонента есть более одной задачи или обязанности, это может привести к сложностям в его поддержке, тестировании и дальнейшем развитии. Разделение обязанностей на более мелкие, но четко определенные модули или компоненты делает код более читаемым, понятным и поддерживаемым. Это также облегчает повторное использование кода и делает его более гибким для изменений в будущем.

## O — Open closed principle — Принцип открытости-закрытости
> Функция или класс должны быть открыты для расширения, но не для модификации.

[Пример на JS](public/2_O.js) - Функции getPrice, animalSound и filterItems не надо изменять

## L — Liskov substitution principle —  Принцип подстановки Лисков
> Если у вас есть функция, которая работает для базового типа, она должна работать и для производного типа.

[Пример на JS](public/3_L.js) -  Мы можем использовать новую функцию calculateVolume везде, где раньше использовалась calculateArea,
 ****
 Допустим, у нас есть функция, которая принимает на вход какие-то данные и возвращает результат. По принципу подстановки Лисков, если вы создаете новую функцию или модифицируете существующую, чтобы она возвращала тот же тип данных и результат, что и оригинальная функция, вы можете использовать эту новую функцию везде, где раньше использовалась оригинальная, без каких-либо изменений в остальном коде.