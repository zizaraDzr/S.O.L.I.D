# SOLID

## S — Single responsibility principle — Принцип единой ответственности
> Функция, класс или модуль должны отвечать только за одну работу, иметь только одну причину для изменений.

[Пример на JS](public/1_S.js) - рендер вынесен в отдельный класс, а не все в одном большой классе.

#### Если говорить о фреймворках - то принцип единой ответственности можно перефразировать по-другому: 

>Каждый компонент должен иметь только одну причину изменения.

Вывод: каждый модуль, класс или компонент должен быть ответственен только за одну конкретную часть функциональности. Иными словами, у модуля должна быть только одна причина для изменения. Если у компонента есть более одной задачи или обязанности, это может привести к сложностям в его поддержке, тестировании и дальнейшем развитии. Разделение обязанностей на более мелкие, но четко определенные модули или компоненты делает код более читаемым, понятным и поддерживаемым. Это также облегчает повторное использование кода и делает его более гибким для изменений в будущем.

## O — Open closed principle — Принцип открытости-закрытости
> Функция или класс должны быть открыты для расширения, но не для модификации.

[Пример на JS](public/2_O.js) - Функции getPrice, animalSound и filterItems не надо изменять

## L — Liskov substitution principle —  Принцип подстановки Лисков
> Если у вас есть функция, которая работает для базового типа, она должна работать и для производного типа.

[Пример на JS](public/3_L.js) -  Мы можем использовать новую функцию calculateVolume везде, где раньше использовалась calculateArea,
 ****
 Допустим, у нас есть функция, которая принимает на вход какие-то данные и возвращает результат. По принципу подстановки Лисков, если вы создаете новую функцию или модифицируете существующую, чтобы она возвращала тот же тип данных и результат, что и оригинальная функция, вы можете использовать эту новую функцию везде, где раньше использовалась оригинальная, без каких-либо изменений в остальном коде.

 ## I — Interface segregation principle — Принцип разделения интерфейсов
 > Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют. Лучше иметь много специфических интерфейсов, чем один интерфейс общего назначения.

[Пример на TS](public/4_I.ts) - в js нет интерфейсов, поэтому пример на TS для наглядности 

#### Если говорить о фреймворках — Когда правило применяется в ситуации с компонентом, это означает, что компонент не должен зависеть от атрибутов или методов, которые он не использует. 

 ## D — Dependency Inversion principle — Принцип инверсии зависимостей
 > Модули высокого уровня не должны зависеть от модулей низкого уровня

 [Пример на TS](public/5_D.ts)  -  Если мы захотим добавить новый тип двигателя, нам не нужно изменять класс Car, мы просто создаем новый класс, реализующий интерфейс EngineInterface, и передаем его в конструктор Car. Это соблюдает принцип инверсии зависимостей и делает код более модульным и расширяемым.